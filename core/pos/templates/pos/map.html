{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Campus Map | Uni360</title>
  <link rel="stylesheet" href="{% static 'pos/style.css' %}">
  <link rel="stylesheet" href="{% static 'pos/map.css' %}">
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Leaflet Routing Machine CSS (not used for custom path routing but kept if you need it later) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />

  <style>
    /* Ensure the map has a visible height (move this to your CSS if you prefer) */
    #map { height: 600px; width: 100%; border-radius: 12px; box-shadow: 0 6px 20px rgba(0,0,0,0.08); }
    .custom-marker { line-height: 0; }
    .user-marker { font-size: 20px; }
    .route-marker { font-size: 18px; }
    .history-item { cursor: pointer; padding: 6px 0; border-bottom: 1px solid #eee; }
    .controls-panel { margin-bottom: 12px; }
  </style>
</head>
<body>
  <div class="sidebar">
    <div>
      <h2 style="display: flex; align-items: center; gap: 10px;">
        <span style="font-size: 24px;">üéì</span>
        <span>Uni360</span>
      </h2>
      <a href="{% url 'dashboard' %}">üè† Dashboard</a>
      <a href="{% url 'map' %}" class="active">üó∫Ô∏è Campus Map</a>
      <a href="{% url 'safety' %}">üõ°Ô∏è Safety</a>
      <a href="{% url 'notifications' %}">üîî Notifications <span id="unread-badge" style="display: none; background: #ff4444; color: white; border-radius: 50%; padding: 2px 6px; font-size: 12px; margin-left: 5px;">0</span></a>
    </div>
    <a href="{% url 'logout' %}" class="logout">Logout</a>
  </div>

  <!-- Top Header -->
  <div class="top-header">
    <div class="search-bar">
      <input type="text" id="search-input" placeholder="Search buildings...">
      <button onclick="searchBuilding()">Searchüîç</button>
    </div>
    <div class="profile-menu">
      <a href="{% url 'profile' %}">
        <img src="{% if user.profile.profile_picture_data %}{{ user.profile.profile_picture_data }}{% else %}{% static 'pos/default-profile.jpg' %}{% endif %}" alt="User Profile Image" class="profile-icon" role="button" tabindex="0" aria-label="Go to profile">
      </a>
    </div>
  </div>

  <div class="content">
    <h1>Campus Navigation üó∫Ô∏è</h1>
    <p>Explore the university campus interactively.</p>
    
    <!-- Controls Panel -->
    <div class="controls-panel">
      <div class="route-controls">
        <select id="start-location">
          <option value="">Select starting point...</option>
          <option value="current">üìç My Current Location</option>
        </select>
        <select id="end-location">
          <option value="">Select destination...</option>
        </select>
        <button onclick="calculateRoute()">üö∂ Get Directions</button>
        <button onclick="clearRoute()">‚úñÔ∏è Clear Route</button>
      </div>
    </div>

    <!-- Map Container -->
    <div id="map"></div>

    <!-- Building Info Panel -->
    <div class="building-info" id="building-info" style="display: none;">
      <h3 id="building-name"></h3>
      <p id="building-description"></p>
      <button onclick="setAsDestination()" class="btn-primary">Set as Destination</button>
    </div>
    <!-- Recent Routes shown under the map -->
    <div id="recent-routes-section" class="recent-routes-section">
      <div class="recent-routes-header">
        <h3>üìç Recent Routes</h3>
        <div class="recent-routes-actions">
          <button id="clear-history" class="clear-history" title="Clear recent routes">Clear</button>
        </div>
      </div>
      <div id="recent-routes" class="recent-routes" aria-live="polite">
        <!-- Filled by displayHistory() -->
      </div>
      <div id="recent-routes-footer" class="recent-routes-footer">
        <button id="show-more-btn" class="show-more" style="display:none">Show more</button>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Leaflet Routing Machine (optional) -->
  <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

  <script>
    // CIT-U Campus buildings
    const buildings = [
      { name: "NGE Building", description: "Administration and main classrooms", latitude: 10.2944, longitude: 123.8811, color: "#6610F2" },
      { name: "GLE Building", description: "Administration and main classrooms", latitude: 10.2953, longitude: 123.8812, color: "#6610F2" },
      { name: "ACAD Building", description: "Administration and main classrooms", latitude: 10.29575, longitude: 123.8810, color: "#6610F2" },
      { name: "RTL Building", description: "Administration and main classrooms", latitude: 10.2948, longitude: 123.8801, color: "#6610F2" },
      { name: "RTL Building", description: "Administration and main classrooms", latitude: 10.2949, longitude: 123.8809, color: "#6610F2" },
      { name: "SAL Building", description: "Administration and main classrooms", latitude: 10.2954, longitude: 123.8800, color: "#6610F2" },
      { name: "ALLIED 1st Building Building", description: "Administration and main classrooms", latitude: 10.2958, longitude: 123.8795, color: "#6610F2" },
      { name: "ALLIED 2nd Building", description: "Administration and main classrooms", latitude: 10.2953, longitude: 123.8797, color: "#6610F2" },
      { name: "ALLIED 3rd Building", description: "Administration and main classrooms", latitude: 10.2947, longitude: 123.8799, color: "#6610F2" },
      { name: "Library", description: "Main campus library with study areas", latitude: 10.29527, longitude: 123.88078, color: "#2EC4B6", type: "library" },
      { name: "Main Canteen", description: "Cafeteria and student activities", latitude: 10.29619, longitude: 123.8805, color: "#FF6B6B", type: "cafeteria" },
      { name: "GYM Canteen", description: "Cafeteria and student activities", latitude: 10.2965, longitude: 123.8798, color: "#FF6B6B", type: "cafeteria" },
      { name: "Gymnasium", description: "Sports facilities and gym", latitude: 10.2963, longitude: 123.8795, color: "#E71D36", type: "sports" },
      { name: "NGE Parking Area", description: "Student and faculty parking", latitude: 10.2944, longitude: 123.8805, color: "#7B68EE", type: "parking" },
      { name: "RTL Parking Area", description: "Student and faculty parking", latitude: 10.2947, longitude: 123.8805, color: "#7B68EE", type: "parking" },
      { name: "GLE Parking Area", description: "Student and faculty parking", latitude: 10.2952, longitude: 123.8810, color: "#7B68EE", type: "parking" },
      { name: "Espacio Parking Area", description: "Student and faculty parking", latitude: 10.2958, longitude: 123.8805, color: "#7B68EE", type: "parking" },
      { name: "Back Gate Parking Area", description: "Student and faculty parking", latitude: 10.2968, longitude: 123.8800, color: "#7B68EE", type: "parking" }
    ];

    // Building type to icon mapping
    const buildingIcons = {
      'library': 'üìö',
      'cafeteria': 'üçΩÔ∏è',
      'sports': '‚öΩ',
      'lab': 'üíª',
      'parking': 'üÖøÔ∏è',
      'default': 'üè¢'
    };

    let map;
    let markers = [];
    let selectedBuilding = null;
    let routingControl = null;
    let userMarker = null;
    let routeHistory = JSON.parse(localStorage.getItem('routeHistory')) || [];
    let campusPathNetwork = null;

    // Layers we manage separately
    let campusLayer = null;         // the campus path network polyline (keep)
    let routeLayer = null;          // polyline for the currently drawn route (remove cleanly)
    let routeMarkers = [];          // markers placed for the route (start/end)
    
    // Haversine distance (meters)
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) ** 2 +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function snapToNearestPath(lat, lon) {
      if (!campusPathNetwork) return [lat, lon];

      const coordinates = campusPathNetwork.geometry.coordinates;
      let nearestPoint = [lat, lon];
      let nearestDistance = Infinity;

      for (let i = 0; i < coordinates.length - 1; i++) {
        const p1 = coordinates[i];
        const p2 = coordinates[i + 1];

        // project point onto segment (p1,p2). coordinates are [lon, lat]
        const denom = ((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2) || 1e-9;
        const t = Math.max(0, Math.min(1, ((lon - p1[0]) * (p2[0] - p1[0]) + (lat - p1[1]) * (p2[1] - p1[1])) / denom));

        const projectedLat = p1[1] + t * (p2[1] - p1[1]);
        const projectedLon = p1[0] + t * (p2[0] - p1[0]);

        const distance = calculateDistance(lat, lon, projectedLat, projectedLon);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestPoint = [projectedLat, projectedLon];
        }
      }

      return nearestPoint;
    }

    function loadCampusPathNetwork() {
      fetch('{% static "pos/campus.json" %}')
        .then(response => {
          if (!response.ok) throw new Error('Network response was not ok');
          return response.json();
        })
        .then(data => {
          if (data.features && data.features.length > 0) {
            campusPathNetwork = data.features[0];
            console.log('Campus path network loaded');

            if (campusPathNetwork.geometry && campusPathNetwork.geometry.type === 'LineString') {
              const pathCoordinates = campusPathNetwork.geometry.coordinates.map(c => [c[1], c[0]]);
              campusLayer = L.polyline(pathCoordinates, {
                color: '#FF6B35',
                weight: 3,
                opacity: 0.8,
                dashArray: '5, 5',
                lineCap: 'round',
                lineJoin: 'round'
              }).addTo(map);
            }
          } else {
            console.warn('Campus path network is empty or malformed');
          }
        })
        .catch(err => console.error('Error loading campus path network:', err));
    }

    function initMap() {
      map = L.map('map').setView([10.2950, 123.8810], 17.5);

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors',
        maxZoom: 19
      }).addTo(map);

      loadCampusPathNetwork();
      populateBuildingSelects();
      addBuildingMarkers();
      getUserLocation();
      displayHistory();

      // Restore selectedRoute if dashboard pushed one
      const selectedRoute = JSON.parse(localStorage.getItem('selectedRoute'));
      if (selectedRoute) {
        localStorage.removeItem('selectedRoute');
        document.getElementById('start-location').value = selectedRoute.start;
        document.getElementById('end-location').value = selectedRoute.end;
        setTimeout(() => calculateRoute(), 800);
      }
    }

    function addBuildingMarkers() {
      markers.forEach(m => map.removeLayer(m));
      markers = [];

      buildings.forEach((building, index) => {
        const icon = buildingIcons[building.type] || buildingIcons.default;
        const customIcon = L.divIcon({
          className: 'custom-marker',
          html: `<div style="background: ${building.color}; color: white; width: 35px; height: 35px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); font-size: 16px;">${icon}</div>`,
          iconSize: [35, 35]
        });

        // Use JSON.stringify to safely inject the building name into inline onclick
        const safeName = JSON.stringify(building.name);

        const popupHtml = `
          <div style="min-width: 200px;">
            <h3 style="color: ${building.color}; margin: 0 0 8px 0;">${building.name}</h3>
            <p style="margin: 0 0 10px 0; color: #666;">${building.description}</p>
            <button onclick="setBuildingAsDestination(${safeName})" 
              style="background: linear-gradient(90deg, #6610F2, #2EC4B6); color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: 600; width: 100%;">
              Get Directions üö∂
            </button>
          </div>
        `;

        const marker = L.marker([building.latitude, building.longitude], { icon: customIcon }).addTo(map);
        marker.bindPopup(popupHtml);

        marker.on('click', () => {
          showBuildingInfo(building);
          selectedBuilding = building;
        });

        markers.push(marker);
      });
    }

    function showBuildingInfo(building) {
      document.getElementById('building-name').textContent = building.name;
      document.getElementById('building-description').textContent = building.description;
      document.getElementById('building-info').style.display = 'block';
    }

    function populateBuildingSelects() {
      const startSelect = document.getElementById('start-location');
      const endSelect = document.getElementById('end-location');

      const uniqueNames = [...new Set(buildings.map(b => b.name))];

      uniqueNames.forEach(name => {
        const startOption = new Option(name, name);
        const endOption = new Option(name, name);
        startSelect.add(startOption);
        endSelect.add(endOption);
      });
    }

    // Called from popup button
    window.setBuildingAsDestination = function(buildingName) {
      document.getElementById('end-location').value = buildingName;
      calculateRoute();
    }

    function setAsDestination() {
      if (selectedBuilding) {
        document.getElementById('end-location').value = selectedBuilding.name;
        calculateRoute();
      }
    }

    function calculateRoute() {
      const start = document.getElementById('start-location').value;
      const end = document.getElementById('end-location').value;

      if (!start || !end) { alert('Please select both starting point and destination.'); return; }
      if (start === end) { alert('Starting point and destination cannot be the same!'); return; }

      // Remove previous route visuals
      clearRoute(false); // keep dropdowns if needed

      if (start === 'current') {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(position => {
            const startCoords = [position.coords.latitude, position.coords.longitude];
            if (userMarker) {
              userMarker.setLatLng(startCoords);
            } else {
              userMarker = L.marker(startCoords, {
                icon: L.divIcon({ html: 'üìç', className: 'user-marker', iconSize: [30, 30] })
              }).addTo(map).bindPopup('You are here!');
            }
            calculateRouteWithCoords(startCoords, end, start);
          }, () => alert('Unable to get your location. Please select a building as starting point.'));
          return;
        } else {
          alert('Geolocation not supported by your browser.');
          return;
        }
      } else {
        const startBuilding = buildings.find(b => b.name === start);
        if (startBuilding) {
          const startCoords = [startBuilding.latitude, startBuilding.longitude];
          calculateRouteWithCoords(startCoords, end, start);
        } else {
          alert('Starting building not found.');
        }
      }
    }

    function findSegmentIndex(lat, lon) {
      if (!campusPathNetwork) return -1;
      const coordinates = campusPathNetwork.geometry.coordinates;
      let minDistance = Infinity;
      let segmentIndex = -1;

      for (let i = 0; i < coordinates.length - 1; i++) {
        const p1 = coordinates[i];
        const p2 = coordinates[i + 1];
        const denom = ((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2) || 1e-9;
        const t = Math.max(0, Math.min(1, ((lon - p1[0]) * (p2[0] - p1[0]) + (lat - p1[1]) * (p2[1] - p1[1])) / denom));
        const projectedLat = p1[1] + t * (p2[1] - p1[1]);
        const projectedLon = p1[0] + t * (p2[0] - p1[0]);
        const distance = calculateDistance(lat, lon, projectedLat, projectedLon);
        if (distance < minDistance) {
          minDistance = distance;
          segmentIndex = i;
        }
      }
      return segmentIndex;
    }

    function calculateRouteAlongPaths(startLat, startLon, endLat, endLon) {
      if (!campusPathNetwork) return [];
      const coordinates = campusPathNetwork.geometry.coordinates;
      const startSegment = findSegmentIndex(startLat, startLon);
      const endSegment = findSegmentIndex(endLat, endLon);
      if (startSegment === -1 || endSegment === -1) return [];

      const routePath = [];
      const minSegment = Math.min(startSegment, endSegment);
      const maxSegment = Math.max(startSegment, endSegment);

      // include points from minSegment to maxSegment (inclusive)
      for (let i = minSegment; i <= maxSegment && i < coordinates.length; i++) {
        const coord = coordinates[i];
        routePath.push([coord[1], coord[0]]);
      }

      return routePath;
    }

    function calculateRouteWithCoords(startCoords, endName, startName) {
      const matchingBuildings = buildings.filter(b => b.name === endName);
      if (matchingBuildings.length === 0) { alert('Destination building not found.'); return; }

      // Choose closest building instance if there are duplicates with same name
      let closestBuilding = matchingBuildings[0];
      let minDistance = Infinity;
      matchingBuildings.forEach(building => {
        const d = map.distance(L.latLng(startCoords), L.latLng(building.latitude, building.longitude));
        if (d < minDistance) { minDistance = d; closestBuilding = building; }
      });

      // Snap start & end to network
      const snappedStart = snapToNearestPath(startCoords[0], startCoords[1]);
      const snappedEnd = snapToNearestPath(closestBuilding.latitude, closestBuilding.longitude);

      // Remove previous route visuals
      if (routeLayer) { map.removeLayer(routeLayer); routeLayer = null; }
      routeMarkers.forEach(m => map.removeLayer(m));
      routeMarkers = [];

      const routePath = calculateRouteAlongPaths(snappedStart[0], snappedStart[1], snappedEnd[0], snappedEnd[1]);

      if (routePath.length > 0) {
        // draw route polyline and keep reference
        routeLayer = L.polyline(routePath, {
          color: '#6610F2',
          opacity: 0.9,
          weight: 6,
          lineCap: 'round',
          lineJoin: 'round'
        }).addTo(map);

        // start marker
        const startMarker = L.marker(L.latLng(snappedStart[0], snappedStart[1]), {
          icon: L.divIcon({ html: 'üö∂', className: 'route-marker start-marker', iconSize: [30, 30] })
        }).bindPopup('Start Point').addTo(map);

        // end marker
        const endMarker = L.marker(L.latLng(snappedEnd[0], snappedEnd[1]), {
          icon: L.divIcon({ html: 'üìç', className: 'route-marker end-marker', iconSize: [30, 30] })
        }).bindPopup('Destination: ' + endName).addTo(map);

        routeMarkers.push(startMarker, endMarker);

        // compute distance
        let totalDistance = 0;
        for (let i = 0; i < routePath.length - 1; i++) {
          totalDistance += map.distance(L.latLng(routePath[i]), L.latLng(routePath[i + 1]));
        }

        // fit map
        const group = L.featureGroup([L.latLng(snappedStart[0], snappedStart[1]), L.latLng(snappedEnd[0], snappedEnd[1])]);
        map.fitBounds(group.getBounds().pad(0.12));

        // save history
        routeHistory.unshift({ start: startName, end: endName, timestamp: new Date().toISOString(), distanceMeters: Math.round(totalDistance) });
        localStorage.setItem('routeHistory', JSON.stringify(routeHistory));
        displayHistory();

      } else {
        alert('Could not find a path between the selected locations.');
      }
    }

    function recalculateRoute(start, end) {
      document.getElementById('start-location').value = start;
      document.getElementById('end-location').value = end;
      calculateRoute();
    }

    let _showAllHistory = false;
    const HISTORY_LIMIT = 6;

    function formatKm(meters) {
      if (!meters && meters !== 0) return '';
      const km = meters / 1000;
      return km < 1 ? `${(meters/1000).toFixed(1)} km` : `${km.toFixed(1)} km`;
    }

    function estimateMinutes(meters) {
      if (!meters && meters !== 0) return '';
      // Rough walking estimate: 1 min per 100m (simple)
      const mins = Math.max(1, Math.round(meters / 100));
      return `${mins} min`;
    }

    function displayHistory() {
      // Prefer the under-map recent routes container, then the map panel fallback, then the old directions-steps id.
      const panelElement = document.getElementById('recent-routes') || document.getElementById('recent-routes-list') || document.getElementById('directions-steps');
      const footerBtn = document.getElementById('show-more-btn');
      if (!panelElement) return; // nothing to render into
      if (!routeHistory || routeHistory.length === 0) {
        panelElement.innerHTML = '<p style="color: rgba(255,255,255,0.85)">No recent routes.</p>';
        if (footerBtn) footerBtn.style.display = 'none';
        return;
      }

      const total = routeHistory.length;
      const limit = _showAllHistory ? total : HISTORY_LIMIT;
      const toRender = routeHistory.slice(0, limit);

      let historyHTML = '';
      toRender.forEach((item, idx) => {
        const timeStr = new Date(item.timestamp).toLocaleString();
        const distanceMeters = item.distanceMeters || 0;
        const distanceLabel = formatKm(distanceMeters);
        const minutesLabel = estimateMinutes(distanceMeters);
        historyHTML += `<div class="history-item" onclick="recalculateRoute('${item.start}', '${item.end}')" role="button" tabindex="0">
                          <div class="history-top">
                            <div class="history-route">${item.start} ‚Üí ${item.end}</div>
                            <div class="history-meta"><span class="distance-badge">${distanceLabel}</span></div>
                          </div>
                          <div class="history-details">${minutesLabel} ¬∑ ${timeStr}</div>
                        </div>`;
      });

      panelElement.innerHTML = historyHTML;

      // show/hide footer show-more button
      if (footerBtn) {
        if (total > HISTORY_LIMIT) {
          footerBtn.style.display = 'inline-block';
          footerBtn.textContent = _showAllHistory ? 'Show less' : `Show more (${total - HISTORY_LIMIT})`;
        } else {
          footerBtn.style.display = 'none';
        }
      }
    }

    function clearHistory() {
      if (!confirm('Clear all recent routes?')) return;
      routeHistory = [];
      localStorage.removeItem('routeHistory');
      displayHistory();
    }

    function toggleShowMore() {
      _showAllHistory = !_showAllHistory;
      displayHistory();
    }

    function clearRoute(resetDropdowns = true) {
      // Remove route visuals only (keep campus path)
      if (routeLayer) { map.removeLayer(routeLayer); routeLayer = null; }
      routeMarkers.forEach(m => map.removeLayer(m));
      routeMarkers = [];

      // hide building info
      document.getElementById('building-info').style.display = 'none';

      // reset selects
      if (resetDropdowns) {
        const startSelect = document.getElementById('start-location');
        const endSelect = document.getElementById('end-location');
        endSelect.value = '';
        if (startSelect.value !== 'current') {
          startSelect.value = '';
        }
      }
    }

    function searchBuilding() {
      const searchTerm = document.getElementById('search-input').value.trim().toLowerCase();
      if (!searchTerm) { alert('Enter a building name or description.'); return; }
      const building = buildings.find(b => b.name.toLowerCase().includes(searchTerm) || (b.description && b.description.toLowerCase().includes(searchTerm)));
      if (building) {
        map.setView([building.latitude, building.longitude], 19);
        showBuildingInfo(building);
        selectedBuilding = building;
        // open corresponding marker popup
        markers.forEach(marker => {
          const pos = marker.getLatLng();
          if (Math.abs(pos.lat - building.latitude) < 1e-6 && Math.abs(pos.lng - building.longitude) < 1e-6) {
            marker.openPopup();
          }
        });
      } else {
        alert('Building not found. Please try another search term.');
      }
    }

    function getUserLocation() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(position => {
          const userCoords = [position.coords.latitude, position.coords.longitude];
          if (userMarker) {
            userMarker.setLatLng(userCoords);
          } else {
            userMarker = L.marker(userCoords, {
              icon: L.divIcon({ html: 'üìç', className: 'user-marker', iconSize: [30, 30] })
            }).addTo(map).bindPopup('You are here!');
          }
        }, error => {
          console.log('Geolocation not available or permission denied', error);
        });
      }
    }

    // init on DOM ready: initialize map and wire recent-routes controls
    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      // wire clear and show more buttons
      const clearBtn = document.getElementById('clear-history');
      if (clearBtn) clearBtn.addEventListener('click', clearHistory);
      const showMoreBtn = document.getElementById('show-more-btn');
      if (showMoreBtn) showMoreBtn.addEventListener('click', toggleShowMore);
      displayHistory();
    });
  </script>
</body>
</html>
